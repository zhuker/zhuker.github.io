<html>
<head>
    <meta charset="utf-8"/>
    <style>
        .error {
            color: red;
        }
        #streamHolder {
            width: 100%;
            height: 100%;               /* whatever size you need */
            display: flex;
            justify-content: center;
            align-items: center;
            background: black;          /* letterbox lives HERE, not in <video> */
            overflow: hidden;           /* optional */
        }

        #streamHolder video {
            height: 100%;
            width: 100%;                /* preserves aspect ratio */
            max-width: 100%;
            max-height: 100%;
            display: block;
        }
    </style>
    <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>
    <script src="RoomSignaling.js"></script>
    <script src="AndroidInputEvents.js"></script>
</head>

<body style="width: 100%; height: 100%; padding: 0; overflow: hidden; margin: 0;">
<div id="statusHolder">Status: <span id="status2"></span> <span id="status"></span><br/></div>
<!-- newer chrome browsers (88+) need user click event to display video -->
<div id="buttonsHolder">
    <button disabled id="play" name="play" value="play" onclick="onplayclicked()">play</button>
    <button disabled id="fullscreenButton" name="fullscreen" value="fullscreen" onclick="onfullscreenClicked()">
        fullscreen
    </button>
    <br/>
</div>
<div id="streamHolder" class="videoContainer">
    <video id="stream"  autoplay playsinline loop></video>
</div>
<div id="logHolder">
    <br/>
    <br/>
    Local Candidates
    <pre id="candidates"></pre>
</div>
</body>
<script>

    function isIOSDevice() {
        const userAgent = navigator.userAgent;
        return /iPad|iPhone|iPod/.test(userAgent) && !window.MSStream; // Exclude Windows phones
    }

    function onplayclicked() {
        getVideoElement().play()
    }

    function onfullscreenClicked() {
        getVideoElement().play()
        streamHolder.requestFullscreen()
    }

    let connect_attempts = 0;
    let peer_connection;
    //let iceServers = [{urls: ["stun:stun.l.google.com:19302"]}];
    // const pcConfig = {
    //     iceServers: [{urls: ["stun:stun.l.google.com:19302"]}]
    // }
    const pcConfig = {
        iceServers: [{"urls": ["turn:54.153.50.217:3478"], "username": "wutwut", "credential": "pp4308"}],
        iceTransportPolicy: "relay"
    };
    function getQueryVariable(variable) {
        const query = window.location.search.substring(1);
        const vars = query.split('&');
        for (let i = 0; i < vars.length; i++) {
            const pair = vars[i].split('=');
            if (decodeURIComponent(pair[0]) === variable) {
                return decodeURIComponent(pair[1]);
            }
        }
        console.log('Query variable not found', variable);
    }

    function getOurId() {
        return parseInt(getQueryVariable("ourid") || Math.floor(Math.random() * (9000 - 10) + 10).toString());
    }

    const placeid = getQueryVariable("placeid")
    const remoteid = getQueryVariable("remoteid")
    const ourid = getOurId();

    const receiverWs = new RoomSignaling("wss://zhuker.video:8443", ourid)

    function getVideoElement() {
        return document.getElementById("stream");
    }

    let dataChannel = null;
    let pingTimer = null;
    let pingCounter = 0

    const handleDataChannelOpen = (event) => {
        console.log("dataChannel.OnOpen", event);
        dataChannel = event.target;
        pingTimer = setInterval(() => {
            if (peer_connection && statusHolder.style.display !== "none") {
                peer_connection.getStats().then(e => {
                    let rtt = 0;
                    e.forEach(report => {
                        if (report.type === "candidate-pair" && report.state === "succeeded") {
                            rtt = Math.max(rtt, ((report.currentRoundTripTime * 1000) | 0))
                        }
                    });
                    setStatus2(`ping ${rtt} msec`);
                })
            }
            const msg = "ping" + pingCounter;
            pingCounter++;
            return dataChannel.send(msg);
        }, 2000);
        if (placeid)
            dataChannel.send(createLaunchGamePacket())
        else
            dataChannel.send(createLaunchRobloxPacket())
    };

    const handleDataChannelMessageReceived = (event) => {
        // console.log("dataChannel.OnMessage:", event, event.data.type);
        // setStatus("Received data channel message " + event.data);
    };

    const handleDataChannelError = (error) => console.log("dataChannel.OnError:", error);

    const handleDataChannelClose = (event) => console.log("dataChannel.OnClose", event);

    function onDataChannel(event) {
        setStatus("Data channel created", event);
        let receiveChannel = event.channel;
        receiveChannel.onopen = handleDataChannelOpen;
        receiveChannel.onmessage = handleDataChannelMessageReceived;
        receiveChannel.onerror = handleDataChannelError;
        receiveChannel.onclose = handleDataChannelClose;
    }

    function resetVideo() {
        // Reset the video element and stop showing the last received frame
        const videoElement = getVideoElement();
        videoElement.pause();
        videoElement.src = "";
        videoElement.load();
    }

    function setStatus(text) {
        console.log(text);
        const span = document.getElementById("status");
        // Don't set the status if it already contains an error
        if (!span.classList.contains('error'))
            span.textContent = text;
    }

    function setStatus2(text) {
        console.log(text);
        const span = document.getElementById("status2");
        // Don't set the status if it already contains an error
        if (!span.classList.contains('error'))
            span.textContent = text;
    }

    function setError(text) {
        console.error(text);
        const span = document.getElementById("status");
        span.textContent = text;
        span.classList.add('error');
    }

    let remoteStream = new MediaStream();

    function onRemoteTrack(event) {
        console.log('onRemoteTrack', event);
        const track = event.track;
        remoteStream.addTrack(track);
        getVideoElement().srcObject = remoteStream;
        getVideoElement().style.backgroundImage = "url(clicktoplay.jpeg)";
        getVideoElement().style.backgroundSize = "contain";
        play.disabled = false;
        fullscreenButton.disabled = false;
    }

    function logIceConnection(msg) {
        console.log(msg);
        let candidatesLog = document.getElementById("candidates");
        if (candidatesLog) {
            candidatesLog.innerText += msg + "\n";
        }
    }

    function extendSdp(sdpDesc) {
        let screenw = screen.width;
        let screenh = screen.height;
        if (isIOSDevice()) {
            screenw = document.body.clientWidth;
            screenh = document.body.clientHeight;
            console.log(`body size ${screenw}x${screenh}`);
        }
        let requestedw = ((screenw * window.devicePixelRatio) | 0) & ~7;
        let requestedh = ((screenh * window.devicePixelRatio) | 0) & ~7;
        console.log(`requested screen size ${requestedw}x${requestedh}`);
        const answerExtended = {
            "type": sdpDesc.type,
            "sdp": sdpDesc.sdp,
            "screen": {
                "width": requestedw,
                "height": requestedh,
                "dpi": (window.devicePixelRatio * 144) | 0,
                "orientation": {
                    "angle": screen.orientation.angle,
                    "type": screen.orientation.type
                }
            }
        }
        if (placeid) {
            // answerExtended['intentData'] = `robloxmobile://placeID=${parseInt(placeid)}`;
        }
        return answerExtended;
    }

    function createPcSendOffer(sendOfferCallback) {
        resetVideo();
        if (peer_connection) {
            peer_connection.close();
            peer_connection = null;
            remoteStream = new MediaStream();
        }
        // Reset connection attempts because we connected successfully
        connect_attempts = 0;

        setStatus('Creating RTCPeerConnection');

        peer_connection = new RTCPeerConnection(pcConfig);
        peer_connection.ondatachannel = onDataChannel;
        peer_connection.ontrack = onRemoteTrack;
        peer_connection.addTransceiver('video', {direction: "recvonly"});
        peer_connection.addTransceiver('audio', {direction: "recvonly"});
        peer_connection.createDataChannel('label', null);

        peer_connection.onicegatheringstatechange = () => {
            logIceConnection('onicegatheringstatechange ' + peer_connection.iceGatheringState)
            if (peer_connection.iceGatheringState === "complete") {
                sendOfferCallback(JSON.stringify(extendSdp(peer_connection.localDescription)));
            }
        }
        peer_connection.onicecandidate = e => {
            if (e.candidate && e.candidate.address) {
                logIceConnection('onicecandidate ' + e.candidate.address + ":" + e.candidate.port)
            } else {
                logIceConnection('onicecandidate ' + e)
            }
        }
        peer_connection.onconnectionstatechange = e => {
            logIceConnection("onconnectionstatechange " + peer_connection.connectionState);
            if (peer_connection.connectionState === "connected") {
                let transceivers = peer_connection.getTransceivers();
                for (let i = 0; i < transceivers.length; i++) {
                    if (transceivers[i].receiver.transport != null) {
                        let pair = transceivers[i].receiver.transport.iceTransport.getSelectedCandidatePair()
                        if (pair.local && pair.remote) {
                            let x = "" + pair.local.address + "";
                            logIceConnection("local candidate: " + x + ":" + pair.local.port)
                            logIceConnection("remote candidate: " + pair.remote.address + ":" + pair.remote.port);
                        } else {
                            logIceConnection("candidate pair: " + JSON.stringify(pair));
                        }
                    }
                }
            }
        }

        peer_connection.createOffer().then(offer => {
            console.log("offer", offer);
            setStatus("Offer created");
            peer_connection.setLocalDescription(offer).then(ok => {
                console.log("local sdp", peer_connection.localDescription);
            })
        })
    }

    receiverWs.onOfferRequested((remoteId) => {
        setStatus("offer requested");
        createPcSendOffer(offerJson => {
            setStatus("offer sent")
            receiverWs.sendOffer(remoteId, offerJson);
            receiverWs.receiveAnswer((remoteId, sdp) => {
                setStatus("answer received")
                if (remoteId !== remoteid) throw new Error("remoteId mismatch");
                const parsed = JSON.parse(sdp);
                if (!parsed) throw new Error("error parsing sdp");
                if (parsed.type !== "answer") throw new Error("type not answer");
                peer_connection.setRemoteDescription(parsed);
            });
        })
    });
    receiverWs.connect(remoteid, (success, peerId) => {
        setStatus(`Connected ${peerId}`);
    }, () => {
        setStatus(`Disconnected ${peerId}`);
    });

    const pointers = new Pointers()

    function isPointerRawUpdateSupported() {
        return 'onpointerrawupdate' in window || 'onpointerrawupdate' in document.createElement('div');
    }

    let pointerUpdateCounter = 0;
    function onPointerUpdate(e) {
        // console.log(e.buttons, e.offsetX, e.offsetY, e.pressure, e.pointerType, e);
        if (!dataChannel || e.buttons === 0)
            return;
        pointerUpdateCounter = pointerUpdateCounter|0;
        pointerUpdateCounter++;
        if ((pointerUpdateCounter & 1) === 0) {
            return;
        }

        let pointerId = e.pointerId;
        if (e.pointerType === "touch") {
            pointerId = pointers.updatePointer(e.pointerId);
        }
        // console.log("pointer update sent");
        dataChannel.send(createTouchEventPacketFromEvent(MotionEvent.ACTION_MOVE, pointerId, e));
    }

    if (isPointerRawUpdateSupported()) {
        getVideoElement().addEventListener("pointerrawupdate", e => {
            // console.log("pointerrawupdate", e.pointerType, e.pointerId, e.buttons);
            e.preventDefault();
            onPointerUpdate(e);
        });
    } else {
        getVideoElement().addEventListener("pointermove", e => {
            console.log("pointermove", e.pointerType, e.pointerId, e.buttons);
            e.preventDefault();
            onPointerUpdate(e);
        });
    }

    let fullscreenClicked = false;
    function fakeFullscreen() {
        if (fullscreenClicked) return;
        fullscreenClicked = true;
        getVideoElement().play();
        if (isIOSDevice()) {
            statusHolder.style.display = "none";
            buttonsHolder.style.display = "none";
            logHolder.style.display = "none";
        } else {
            streamHolder.requestFullscreen();
        }
    }


    getVideoElement().addEventListener("pointerdown", e => {
        fakeFullscreen();
        e.preventDefault();
        let [x, y] = getIntrinsicXY(e.target, e);
        console.log("Pressed", e.button, e.pointerType, x, y);
        if (!dataChannel)
            return;
        let pointerId = e.pointerId;
        if (e.pointerType === "touch") {
            pointerId = pointers.updatePointer(e.pointerId);
        }
        dataChannel.send(createTouchEventPacketFromEvent(MotionEvent.ACTION_DOWN, pointerId, e));
    });
    getVideoElement().addEventListener("pointerup", e => {
        e.preventDefault();
        let [x, y] = getIntrinsicXY(e.target, e);
        console.log("Released", e.button, e.pointerType, x, y);
        if (!dataChannel)
            return;
        let pointerId = e.pointerId;
        if (e.pointerType === "touch") {
            pointerId = pointers.deletePointer(e.pointerId);
        }
        dataChannel.send(createTouchEventPacketFromEvent(MotionEvent.ACTION_UP, pointerId, e));
    });

    window.addEventListener("keydown", e => {
        console.log(e.code, CodeToAndroidKeyCode[e.code], e.repeat, e.shiftKey);
        if (!dataChannel)
            return;
        const packet = keyboardEventToPacket(e)
        dataChannel.send(packet);
    });
    window.addEventListener("keyup", e => {
        console.log(e.code, CodeToAndroidKeyCode[e.code], e.repeat, e.shiftKey);
        if (!dataChannel)
            return;
        const packet = keyboardEventToPacket(e)
        dataChannel.send(packet);
    });

    function disableTouch(event) {
        event.preventDefault();
        event.stopPropagation();
    }

    // Add listeners when the video goes fullscreen
    // You might want to wrap this in logic for when the video actually enters fullscreen.
    getVideoElement().addEventListener('touchstart', disableTouch);
    getVideoElement().addEventListener('touchmove', disableTouch);
    getVideoElement().addEventListener('touchend', disableTouch);
    getVideoElement().addEventListener('touchcancel', disableTouch);
    /*
        function useStun() {
            return "false" !== getQueryVariable("usestun") || !document.getElementById("no_stun_checkbox").checked
        }

        document.getElementById("no_stun_checkbox").onchange = e => {
            console.log(e);
            if (e.target.checked) {
                iceServers = [];
            } else {
                iceServers = [{urls: ["stun:stun.l.google.com:19302"]}];
            }
        }
        if ("false" === getQueryVariable("usestun")) {
            iceServers = [];
            document.getElementById("no_stun_checkbox").checked = true;
        }


        function resetState() {
            // This will call onServerClose()
            ws_conn.close();
        }

        function handleIncomingError(error) {
            setError("ERROR: " + error);
            resetState();
        }


        function setStatus(text) {
            console.log(text);
            const span = document.getElementById("status");
            // Don't set the status if it already contains an error
            if (!span.classList.contains('error'))
                span.textContent = text;
        }

        function setError(text) {
            console.error(text);
            const span = document.getElementById("status");
            span.textContent = text;
            span.classList.add('error');
        }

        function resetVideo() {
            // Release the webcam and mic
            if (local_stream_promise)
                local_stream_promise.then(stream => {
                    if (stream) {
                        stream.getTracks().forEach(function (track) {
                            track.stop();
                        });
                    }
                });

            // Reset the video element and stop showing the last received frame
            const videoElement = getVideoElement();
            videoElement.pause();
            videoElement.src = "";
            videoElement.load();
        }

        // SDP offer received from peer, set remote description and create an answer
        function onIncomingSDP(sdp) {
            peer_connection.setRemoteDescription(sdp).then(() => {
                setStatus("Remote SDP set");
                if ("offer" !== sdp.type)
                    return;
                setStatus("Got SDP offer");
                local_stream_promise.then((stream) => {
                    setStatus("Got local stream, creating answer");
                    peer_connection.createAnswer()
                        .then(onLocalDescription).catch(setError);
                }).catch(setError);
            }).catch(setError);
        }

        // Local description was set, send it to peer
        function onLocalDescription(desc) {
            console.log("Got local description: " + JSON.stringify(desc));
            peer_connection.setLocalDescription(desc).then(function () {
                setStatus("Sending SDP " + desc.type);
            });
        }

        function generateOffer() {
            peer_connection.createOffer().then(onLocalDescription).catch(setError);
        }

        // ICE candidate received from peer, add it to the peer connection
        function onIncomingICE(ice) {
            const candidate = new RTCIceCandidate(ice);
            let candidatesLog = document.getElementById("candidates");
            if (candidatesLog) {
                candidatesLog.innerText += candidate.address + ":" + candidate.port + "\n";
            }
            peer_connection.addIceCandidate(candidate).catch(setError);

        }

        function onServerMessage(event) {
            console.log("Received " + event.data);
            switch (event.data) {
                case "HELLO":
                    setStatus("Registered with server, waiting for call");
                    return;
                default:
                    if (event.data.startsWith("ERROR")) {
                        handleIncomingError(event.data);
                        return;
                    }
                    if (event.data.startsWith("OFFER_REQUEST")) {
                        // The peer wants us to set up and then send an offer
                        createCall(null).then(generateOffer);
                    } else {
                        // Handle incoming JSON SDP and ICE messages
                        let msg;
                        try {
                            msg = JSON.parse(event.data);
                        } catch (e) {
                            if (e instanceof SyntaxError) {
                                handleIncomingError("Error parsing incoming JSON: " + event.data);
                            } else {
                                handleIncomingError("Unknown error parsing response: " + event.data);
                            }
                            return;
                        }

                        // Incoming JSON signals the beginning of a call
                        if (!peer_connection)
                            createCall(msg);

                        if (msg.type != null) {
                            onIncomingSDP(msg);
                        } else if (msg.candidate != null) {
                            onIncomingICE(msg);
                        } else {
                            handleIncomingError("Unknown incoming JSON: " + msg);
                        }
                    }
            }
        }

        function onServerClose(event) {
            setStatus('Disconnected from server');

            // Reset after a second
            window.setTimeout(websocketServerConnect, 1000);
        }

        function onServerError(event) {
            setError("Unable to connect to server, did you add an exception for the certificate?")
            // Retry after 3 seconds
            window.setTimeout(websocketServerConnect, 3000);
        }

        function websocketServerConnect() {
            connect_attempts++;
            if (connect_attempts > 3) {
                setError("Too many connection attempts, aborting. Refresh page to try again");
                return;
            }
            // Clear errors in the status span
            const span = document.getElementById("status");
            span.classList.remove('error');
            span.textContent = '';
            // Fetch the peer id to use
            setStatus("Connecting to server " + ws_url);
            ws_conn = new WebSocket(ws_url);
            // When connected, immediately register with the server
            ws_conn.addEventListener('open', (event) => {
                document.getElementById("peer-id").textContent = peer_id;
                ws_conn.send('HELLO ' + peer_id);
                setStatus("Registering with server");
            });
            ws_conn.addEventListener('error', onServerError);
            ws_conn.addEventListener('message', onServerMessage);
            ws_conn.addEventListener('close', onServerClose);
        }

        function onRemoteTrack(event) {
            console.log('onRemoteTrack', event);
            if (getVideoElement().srcObject !== event.streams[0]) {
                console.log('Incoming stream', event);
                console.log('Incoming stream', event.streams);
                console.log('Incoming track', event.track);
                if (event.streams && event.streams.length !== 0) {
                    getVideoElement().srcObject = event.streams[0];
                } else {
                    getVideoElement().srcObject = new MediaStream([event.track])
                }
                play.disabled = false;
            }
        }

        let dataChannel = null;
        let pingTimer = null;
        let pingCounter = 0

        const handleDataChannelOpen = (event) => {
            console.log("dataChannel.OnOpen", event);
            dataChannel = event.target;
            pingTimer = setInterval(() => {
                let msg = "ping" + pingCounter;
                pingCounter++;
                return dataChannel.send(msg);
            }, 2000);
        };

        const handleDataChannelMessageReceived = (event) => {
            console.log("dataChannel.OnMessage:", event, event.data.type);

            setStatus("Received data channel message " + event.data);
            send_channel.send("Hi! (from browser)");
        };

        const handleDataChannelError = (error) => console.log("dataChannel.OnError:", error);

        const handleDataChannelClose = (event) => console.log("dataChannel.OnClose", event);

        function onDataChannel(event) {
            setStatus("Data channel created");
            let receiveChannel = event.channel;
            receiveChannel.onopen = handleDataChannelOpen;
            receiveChannel.onmessage = handleDataChannelMessageReceived;
            receiveChannel.onerror = handleDataChannelError;
            receiveChannel.onclose = handleDataChannelClose;
        }

        function createCall(msg) {
            resetVideo();

            if (peer_connection) {
                peer_connection.close();
                peer_connection = null;
            }
            // Reset connection attempts because we connected successfully
            connect_attempts = 0;

            console.log('Creating RTCPeerConnection');

            peer_connection = new RTCPeerConnection({
                iceServers: iceServers
            });
            send_channel = peer_connection.createDataChannel('label', null);
            send_channel.onopen = handleDataChannelOpen;
            send_channel.onmessage = handleDataChannelMessageReceived;
            send_channel.onerror = handleDataChannelError;
            send_channel.onclose = handleDataChannelClose;
            peer_connection.ondatachannel = onDataChannel;
            peer_connection.ontrack = onRemoteTrack;
            peer_connection.addTransceiver('video', {direction: "recvonly"});
            local_stream_promise = Promise.resolve();

            if (msg != null && !msg.sdp) {
                console.log("WARNING: First message wasn't an SDP message!?");
            }

            peer_connection.onicegatheringstatechange = () => {
                console.log('onicegatheringstatechange', peer_connection.iceGatheringState);
                if (peer_connection.iceGatheringState === "complete") {
                    ws_conn.send(JSON.stringify(peer_connection.localDescription));
                }
            }
            peer_connection.onicecandidate = e => {
                console.log("onicecandidate", e)
                let candidatesLog = document.getElementById("candidates");
                if (candidatesLog && e.candidate && e.candidate.address) {
                    candidatesLog.innerText += e.candidate.address + ":" + e.candidate.port + "\n";
                }
            }
            peer_connection.oniceconnectionstatechange = e => {
                console.log("oniceconnectionstatechange", e)
                ///peer_connection.getTransceivers()[0].receiver.transport.iceTransport.getSelectedCandidatePair()
                let candidatesLog = document.getElementById("candidates");
                if (candidatesLog) {
                    candidatesLog.innerText += "iceConnectionState: " + peer_connection.iceConnectionState + "\n";
                }
            }

            peer_connection.onconnectionstatechange = e => {
                console.log("onconnectionstatechange", e)
                let candidatesLog = document.getElementById("candidates");
                if (candidatesLog) {
                    candidatesLog.innerText += "connectionState: " + peer_connection.connectionState + "\n";
                    if (peer_connection.connectionState === "connected") {
                        let pair = peer_connection.getTransceivers()[0].receiver.transport.iceTransport.getSelectedCandidatePair()
                        if (pair.local && pair.remote) {
                            let x = "" + pair.local.address + "";
                            console.log(x);
                            candidatesLog.innerText += "local candidate: " + x + ":" + pair.local.port + "\n";
                            candidatesLog.innerText += "remote candidate: " + pair.remote.address + ":" + pair.remote.port + "\n";

                        } else {
                            candidatesLog.innerText += "candidate pair: " + JSON.stringify(pair) + "\n";
                        }
                    }
                }
            }


            if (msg != null)
                setStatus("Created peer connection for call, waiting for SDP");

            return local_stream_promise;
        }

        window.onload = websocketServerConnect;


     */

</script>
</html>
